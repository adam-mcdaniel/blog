{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/the-oak-compiler","result":{"data":{"markdownRemark":{"id":"a5099d96-1df5-5dbd-ac6f-113d8bbacbd3","html":"<p>I’ve written an alternative to the C programming language. This is how it\nworks, and what I’ve learned.</p>\n<h2 id=\"free\" style=\"position:relative;\"><a href=\"#free\" aria-label=\"free permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Free</h2>\n<p>About 6 months ago, I began exploring compilers with <a href=\"https://en.wikipedia.org/wiki/Turing_tarpit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>extremely limited</em></a> target backends. I came across <a href=\"https://github.com/brain-lang/brain\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the brain programming language</a> and I was <em>immediately</em> inspired. How could a high level programming language possibly use such a tiny backend? It was incredibly interesting to me, so I decided to write my own language, <a href=\"https://github.com/adam-mcdaniel/free\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">free</a>. It used a super-set of Brain**** with 3 new instructions for dynamic memory management. After a substantial amount of keyboard clacking and lots of confusion, I had accidentally made a working compiler! The end result looked like this:</p>\n<p><img src=\"/blog/media/free.png\" alt=\"Free Code\"></p>\n<p>I couldn’t believed it worked; it was incredible. The only problem was that <em><strong>free was absolute garbage</strong></em>. It couldn’t be used for anything. At all. There wasn’t a type system, memory was basically impossible to manage, there wasn’t any kind of IO other than STDIN and STDOUT, there was no error checking system of any kind, etc. I loved my creation, but it wasn’t practical.</p>\n<h2 id=\"oaks-conception\" style=\"position:relative;\"><a href=\"#oaks-conception\" aria-label=\"oaks conception permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Oak’s Conception</h2>\n<p>Then, I had an idea. What if I kept the tape memory structure from Brain****, kept the memory management operations from free, and added some operators for managing a stack? The result was Oak’s backend assembly language. After a week of experimenting, I created an incredibly reduced instruction set with only 12 operators that could output basic C code. <em>“This is perfect”</em>, I thought. I implemented an intermediate representation that implemented functions, structures, a type system, and basic operations that any programming language needs. I even added a foreign function interface, so that users could import C code into their programs! I was incredibly excited.</p>\n<p><img src=\"/blog/media/oak.png\" alt=\"Oak Code\"></p>\n<p>It was at about this point that the language took* off on Reddit, HackerNews, and GitHub. Only a <em>single day</em> after posting the GitHub link to Reddit, I had over <strong><em>16,000</em></strong> unique visitors to the repository. I had never received much attention on Reddit or GitHub, so this was incredibly powerful to me. It fueled me to keep going.</p>\n<p>At around this point, the project was still pretty barebones. It had all the basic necessities, but nothing more. There was still a <em>lot</em> to be done. Oak was basically just a glorified, stripped down, and less robust C compiler.</p>\n<h2 id=\"typechecking-is-hard\" style=\"position:relative;\"><a href=\"#typechecking-is-hard\" aria-label=\"typechecking is hard permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Typechecking is hard</h2>\n<p>Although I knew typechecking could get complicated, I didn’t know it would take up about <em>half of my intermediate representation’s codebase</em>. Typechecking isn’t about confirming if a program is correct, it’s about confirming a program <strong>isn’t</strong> correct. Although that distinction might sound a bit unnecessary, I assure you it is not. Typechecking is difficult because you have to consider <strong>every incorrect program possible</strong>, and try to eliminate each one. It’s almost impossible to get right, and there are probably dozens of logic errors in Oak’s type system <em>right now</em>. <em>But</em>, in the end, it works pretty well. It’s mostly just the fringe cases that are a bit off.</p>\n<p><img src=\"/blog/media/typecheck.png\" alt=\"Typechecking\"></p>\n<p>By far, the hardest part is typechecking the code responsible for automatic memory management. There are so many things that can go wrong, it’s unbelievable how easy it is to screw up. One big problem I ran into was determining whether or not a structure <em>needed</em> to use automatic memory management <em>at all</em>. Why use copy constructors and destructors for a type that doesn’t have any members with copy constructors or destructors? And how do you confirm that all objects’ destructors will be called? After some experimenting, I think I figured out an air tight solution, but honestly <em>I really don’t know if there are ways to abuse the automatic memory management system</em>.</p>","fields":{"slug":"/posts/the-oak-compiler","tagSlugs":["/tag/imperative-programming/","/tag/turing-tarpit/","/tag/compilers/"]},"frontmatter":{"date":"2020-08-27T11:52:37.121Z","description":"I've written an alternative to the C programming language. This is how it works, and what I've learned.","tags":["Imperative Programming","Turing Tarpit","Compilers"],"title":"The Oak Compiler","socialImage":"/blog/media/oak.png"}}},"pageContext":{"slug":"/posts/the-oak-compiler"}},"staticQueryHashes":["251939775","3942705351","401334301"]}